{"version":3,"sources":["debounce.ts"],"names":[],"mappings":";AAkLe,aAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,aAAA,EAAA,QAAA,SAAA,EAhLf,IAAI,EAAkB,sBAElB,EAAY,KAAK,IACnB,EAAY,KAAK,IAoCb,SAAU,EAAS,GAChB,MAAc,UAAd,EAAO,GAEV,SAAU,EACd,EACA,EACA,QADA,IAAA,IAAA,EAAA,UACA,IAAA,IAAA,EAAA,CAAsB,SAAS,EAAM,UAAU,EAAM,QAAS,MAE1D,IAAA,EACF,EACA,EACA,EACA,EACA,EACA,EAAiB,EACjB,GAAU,EACV,GAAS,EACT,GAAW,EAET,GAAe,mBAAR,EACH,MAAA,IAAI,UAAU,GAUb,SAAA,EAAW,GAEd,IAAA,EAAO,EACT,EAAU,EAKL,OAHP,EAAW,OAAW,EACtB,EAAiB,EACjB,EAAS,EAAK,MAAM,EAAS,GAoBtB,SAAA,EAAa,GAEhB,IAAA,EAAoB,EAAO,EAI7B,YAAiB,IAAjB,GACA,GAAqB,GACrB,EAAoB,GACnB,GANqB,EAAO,GAMK,EAI7B,SAAA,IAEH,IAAA,EAAO,IAAI,KACX,GAAA,EAAa,GAER,OAAA,EAAa,GAEtB,EAAU,WAAW,EA7Bd,SAAc,GAEjB,IAEF,EAAS,GAFa,EAAO,GAIxB,OAAA,EAAS,EAAU,EAAQ,GAHV,EAAO,IAGoC,EAuBhC,CAAc,IAG1C,SAAA,EAAa,GAMhB,OAJJ,OAAU,EAIN,GAAY,EAEP,EAAW,IAEpB,EAAW,OAAW,EACf,GAiBA,SAAA,IACH,IAAA,EAAO,IAAI,KACb,EAAa,EAAa,GAMxB,GAJJ,EAAW,UACX,EAAW,KACX,EAAe,EAEX,EAAY,CACV,QAAY,IAAZ,EAEK,OA9EJ,SAAY,GAIZ,OAFP,EAAiB,EACjB,EAAU,WAAW,EAAc,GAC5B,EAAU,EAAW,GAAQ,EA0EzB,CAAY,GAEjB,GAAA,EAGK,OADP,EAAU,WAAW,EAAc,GAC5B,EAAW,GAOf,YAJS,IAAZ,IAEF,EAAU,WAAW,EAAc,IAE9B,EAIF,OAjHP,EAAO,OAAO,IAAS,EACnB,EAAS,KACX,IAAY,EAAQ,QAEpB,GADA,EAAS,YAAa,GACH,EAAU,OAAO,EAAQ,UAAY,EAAG,GAAQ,EACnE,EAAW,aAAc,IAAY,EAAQ,SAAW,GA0G1D,EAAU,OAvCD,gBAES,IAAZ,GACF,aAAa,GAEf,EAAiB,EACjB,EAAW,EAAe,EAAW,OAAU,GAkCjD,EAAU,MA/BD,WAEA,YAAY,IAAZ,EAAwB,EAAS,EAAa,IAAI,OA8BpD,EAEM,IAAA,EAAA,CACb,SAAQ,GADK,QAAA,QAAA","file":"debounce.js","sourceRoot":"..\\..\\src","sourcesContent":["//debounce.js\r\n\r\nvar FUNC_ERROR_TEXT = \"Expected a function\";\r\n\r\nvar nativeMax = Math.max, //原生最大值方法\r\n  nativeMin = Math.min; //原生最小值方法\r\ninterface IOptions {\r\n  leading: boolean;\r\n  trailing: boolean;\r\n  maxWait: number;\r\n}\r\n/**\r\n * 函数去抖，也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。\r\n *\r\n * @param {Function} func 需要去抖的函数.\r\n * @param {number} [wait=0] 延迟执行的时间.\r\n * @param {Object} [options={}] 选项对象.\r\n * @param {boolean} [options.leading=false] 指定是否在超时前调用.\r\n * @param {number} [options.maxWait] func延迟调用的最大时间.\r\n * @param {boolean} [options.trailing=true] 指定是否在超时后调用.\r\n * @returns {Function} 返回去抖之后的函数.\r\n * @example\r\n *\r\n * // Avoid costly calculations while the window size is in flux.\r\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\r\n *\r\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\r\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\r\n *   'leading': true,\r\n *   'trailing': false\r\n * }));\r\n *\r\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\r\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\r\n * var source = new EventSource('/stream');\r\n * jQuery(source).on('message', debounced);\r\n *\r\n * // Cancel the trailing debounced invocation.\r\n * jQuery(window).on('popstate', debounced.cancel);\r\n */\r\n\r\nexport function isObject(obj) {\r\n  return typeof obj == \"object\";\r\n}\r\nexport function debounce(\r\n  func: Function,\r\n  wait: number = 1000,\r\n  options: IOptions = { leading: true, trailing: true, maxWait: 100000 }\r\n): Function {\r\n  var lastArgs, //上次调用参数\r\n    lastThis, //上次调用this\r\n    maxWait, //最大等待时间\r\n    result, //返回结果\r\n    timerId, //timerId\r\n    lastCallTime, //上次调用debounced时间,即触发时间，不一定会调用func\r\n    lastInvokeTime = 0, //上次调用func时间，即成功执行时间\r\n    leading = false, //超时之前\r\n    maxing = false, //是否传入最大超时时间\r\n    trailing = true; //超时之后\r\n\r\n  if (typeof func != \"function\") {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  wait = Number(wait) || 0;\r\n  if (isObject(options)) {\r\n    leading = !!options.leading;\r\n    maxing = \"maxWait\" in options;\r\n    maxWait = maxing ? nativeMax(Number(options.maxWait) || 0, wait) : maxWait;\r\n    trailing = \"trailing\" in options ? !!options.trailing : trailing;\r\n  }\r\n\r\n  function invokeFunc(time) {\r\n    //调用func，参数为当前时间\r\n    var args = lastArgs, //调用参数\r\n      thisArg = lastThis; //调用的this\r\n\r\n    lastArgs = lastThis = undefined; //清除lastArgs和lastThis\r\n    lastInvokeTime = time; //上次调用时间为当前时间\r\n    result = func.apply(thisArg, args); //调用func，并将结果返回\r\n    return result;\r\n  }\r\n\r\n  function leadingEdge(time) {\r\n    //超时之前调用\r\n    lastInvokeTime = time; //设置上次调用时间为当前时间\r\n    timerId = setTimeout(timerExpired, wait); //开始timer\r\n    return leading ? invokeFunc(time) : result; //如果leading为true，调用func,否则返回result\r\n  }\r\n\r\n  function remainingWait(time) {\r\n    //设置还需要等待的时间\r\n    var timeSinceLastCall = time - lastCallTime, //距离上次触发的时间\r\n      timeSinceLastInvoke = time - lastInvokeTime, //距离上次调用func的时间\r\n      result = wait - timeSinceLastCall; //还需要等待的时间\r\n\r\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\r\n  }\r\n\r\n  function shouldInvoke(time) {\r\n    //是否应该被调用\r\n    var timeSinceLastCall = time - lastCallTime, //距离上次触发时间的时间\r\n      timeSinceLastInvoke = time - lastInvokeTime; //距离上次调用func的时间\r\n\r\n    return (\r\n      lastCallTime === undefined ||\r\n      timeSinceLastCall >= wait ||\r\n      timeSinceLastCall < 0 ||\r\n      (maxing && timeSinceLastInvoke >= maxWait)\r\n    );\r\n  }\r\n\r\n  function timerExpired() {\r\n    //刷新timer\r\n    var time = new Date();\r\n    if (shouldInvoke(time)) {\r\n      //如果可以调用，调用trailingEdge\r\n      return trailingEdge(time);\r\n    }\r\n    timerId = setTimeout(timerExpired, remainingWait(time)); //不调用则重置timerId\r\n  }\r\n\r\n  function trailingEdge(time) {\r\n    //超时之后调用\r\n    timerId = undefined;\r\n\r\n    // Only invoke if we have `lastArgs` which means `func` has been\r\n    // debounced at least once.\r\n    if (trailing && lastArgs) {\r\n      //如果设置trailing为true,并且有lastArgs，调用func\r\n      return invokeFunc(time);\r\n    }\r\n    lastArgs = lastThis = undefined; //清除lastArgs和lastThis\r\n    return result; //否则返回result\r\n  }\r\n\r\n  function cancel() {\r\n    //取消执行\r\n    if (timerId !== undefined) {\r\n      clearTimeout(timerId);\r\n    }\r\n    lastInvokeTime = 0;\r\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n  }\r\n\r\n  function flush() {\r\n    //直接执行\r\n    return timerId === undefined ? result : trailingEdge(new Date());\r\n  }\r\n\r\n  function debounced(this: any) {\r\n    var time = new Date(),\r\n      isInvoking = shouldInvoke(time); //判断是否可以调用\r\n\r\n    lastArgs = arguments; //得到参数\r\n    lastThis = this; //得到this对象\r\n    lastCallTime = time; //触发时间\r\n\r\n    if (isInvoking) {\r\n      if (timerId === undefined) {\r\n        //首次触发，调用leadingEdge\r\n        return leadingEdge(lastCallTime);\r\n      }\r\n      if (maxing) {\r\n        // 处理多次频繁的调用\r\n        timerId = setTimeout(timerExpired, wait); //设置定时器\r\n        return invokeFunc(lastCallTime);\r\n      }\r\n    }\r\n    if (timerId === undefined) {\r\n      //如果没有timer,设置定时器\r\n      timerId = setTimeout(timerExpired, wait);\r\n    }\r\n    return result; //返回result\r\n  }\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n  return debounced;\r\n}\r\nexport default {\r\n  debounce,\r\n};\r\n"]}